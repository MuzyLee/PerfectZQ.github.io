---
layout: post
title: Python可迭代对象介绍
tag: Python
---

　　Python可迭代对象与列表不同，列表中如果有10000个对象，那么在构造这个列表的时候就需要占用10000个对象的内存，而可迭代对象就不会占用这么多内存。generator保存的是算法，真正需要获取值的时候才会去计算下一个值，属于惰性计算(lazy evaluation)。

　　最简单的例子如内置函数 `range(1, 10)` 与 `xrange(1, 10)`，前者生成一个1到9的列表，后者生成一个1到9的可迭代对象。

在Python中创建generator有两种方式
### 1、使用 Generator Function
构造一个函数，通过yield关键词返回可迭代对象
```python
def get_generator():
    for i in range(1, 10):
        yield i

generator = get_generator()
```
### 2、通过 () 与for循环构造可迭代对象
```python
lists = [[1, 2], [3, 4, 5], [6, 7, 8]]
# 生成 1 - 8 的可迭代对象
generator = (x for list in lists for x in list)
# 生成 1 - 8 中为偶数的可迭代对象
generator = (x for list in lists for x in list if x % 2 == 0)
```
### 通过for循环生成list列表
```python
# 生成 2，4，6，8
list = [x * 2 for x in xrange(1, 5)]
```
### 通过for循环生成dict字典
```python
# 键值是键的2倍
dict = {x : x * 2 for x in xrange(1, 5)}
```
### 通过for循环生成set集合
```python
# set([1, 2, 3, 4]) 等价于 {1, 2, 3, 4}
set = {x for x in xrange(1, 5)}
```
**注:** 另外，dict 是 `unhashable type: 'dict'` 所以不可以将list dict转换成set dict，即不会存在set dict这种东西。如果想将list dict进行去重操作，可以使用下面的方法：
```python
list_dict = [
               {
                   "date": "2017-9-30",
                   "status": "2"
               },
               {
                   "date": "2017-10-1",
                   "status": "1"
               },
               {
                   "date": "2017-10-1",
                   "status": "1"
               }
           ]
def deduplicate_list_dict(list_dict) = 
    deduplicate_set = set()
    for dict in list_dict:
        if dict['date'] not in deduplicate_set:
            yield dict
            deduplicate_set.add(dict['date'])
```